//
// Generated by Bluespec Compiler, version 2013.12.beta1 (build 32746, 2013-12-02)
//
// On Wed Mar  5 21:31:18 CST 2014
//
//
// Ports:
// Name                         I/O  size props
// read                           O    16
// CLK                            I     1 clock
// RST_N                          I     1 reset
// write_x                        I    16
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkSOP2(CLK,
	      RST_N,

	      write_x,

	      read);
  input  CLK;
  input  RST_N;

  // action method write
  input  [15 : 0] write_x;

  // value method read
  output [15 : 0] read;

  // signals for module outputs
  wire [15 : 0] read;

  // register taps_0
  reg [31 : 0] taps_0;
  wire [31 : 0] taps_0$D_IN;
  wire taps_0$EN;

  // register taps_1
  reg [31 : 0] taps_1;
  wire [31 : 0] taps_1$D_IN;
  wire taps_1$EN;

  // register taps_2
  reg [31 : 0] taps_2;
  wire [31 : 0] taps_2$D_IN;
  wire taps_2$EN;

  // register taps_3
  reg [31 : 0] taps_3;
  wire [31 : 0] taps_3$D_IN;
  wire taps_3$EN;

  // register y
  reg [31 : 0] y;
  wire [31 : 0] y$D_IN;
  wire y$EN;

  // remaining internal signals
  wire [31 : 0] SEXT_y_BITS_31_TO_8__q2;
  wire [23 : 0] y_BITS_31_TO_8__q1;

  // value method read
  assign read = SEXT_y_BITS_31_TO_8__q2[15:0] ;

  // register taps_0
  assign taps_0$D_IN = { {16{write_x[15]}}, write_x } ;
  assign taps_0$EN = 1'd1 ;

  // register taps_1
  assign taps_1$D_IN = taps_0 ;
  assign taps_1$EN = 1'd1 ;

  // register taps_2
  assign taps_2$D_IN = taps_1 ;
  assign taps_2$EN = 1'd1 ;

  // register taps_3
  assign taps_3$D_IN = taps_2 ;
  assign taps_3$EN = 1'd1 ;

  // register y
  assign y$D_IN =
	     { taps_0[25:0], 6'd0 } + { taps_1[25:0], 6'd0 } +
	     { taps_2[25:0], 6'd0 } +
	     { taps_3[25:0], 6'd0 } ;
  assign y$EN = 1'd1 ;

  // remaining internal signals
  assign SEXT_y_BITS_31_TO_8__q2 =
	     { {8{y_BITS_31_TO_8__q1[23]}}, y_BITS_31_TO_8__q1 } ;
  assign y_BITS_31_TO_8__q1 = y[31:8] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        taps_0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	taps_1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	taps_2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	taps_3 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	y <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (taps_0$EN) taps_0 <= `BSV_ASSIGNMENT_DELAY taps_0$D_IN;
	if (taps_1$EN) taps_1 <= `BSV_ASSIGNMENT_DELAY taps_1$D_IN;
	if (taps_2$EN) taps_2 <= `BSV_ASSIGNMENT_DELAY taps_2$D_IN;
	if (taps_3$EN) taps_3 <= `BSV_ASSIGNMENT_DELAY taps_3$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    taps_0 = 32'hAAAAAAAA;
    taps_1 = 32'hAAAAAAAA;
    taps_2 = 32'hAAAAAAAA;
    taps_3 = 32'hAAAAAAAA;
    y = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkSOP2

